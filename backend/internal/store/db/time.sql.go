// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: time.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countTimes = `-- name: CountTimes :one
SELECT COUNT(*) FROM times t
JOIN meets m ON m.id = t.meet_id
WHERE t.swimmer_id = $1
  AND ($2::varchar = '' OR m.course_type = $2)
  AND ($3::varchar = '' OR t.event = $3)
  AND ($4::uuid = '00000000-0000-0000-0000-000000000000' OR t.meet_id = $4)
`

type CountTimesParams struct {
	SwimmerID uuid.UUID `json:"swimmer_id"`
	Column2   string    `json:"column_2"`
	Column3   string    `json:"column_3"`
	Column4   uuid.UUID `json:"column_4"`
}

func (q *Queries) CountTimes(ctx context.Context, arg CountTimesParams) (int64, error) {
	row := q.db.QueryRow(ctx, countTimes,
		arg.SwimmerID,
		arg.Column2,
		arg.Column3,
		arg.Column4,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countTimesByEvent = `-- name: CountTimesByEvent :many
SELECT event, COUNT(*)::int AS count
FROM times t
JOIN meets m ON m.id = t.meet_id
WHERE t.swimmer_id = $1
  AND ($2::varchar = '' OR m.course_type = $2)
GROUP BY event
ORDER BY event
`

type CountTimesByEventParams struct {
	SwimmerID uuid.UUID `json:"swimmer_id"`
	Column2   string    `json:"column_2"`
}

type CountTimesByEventRow struct {
	Event string `json:"event"`
	Count int32  `json:"count"`
}

// Returns count of times per event for a swimmer
func (q *Queries) CountTimesByEvent(ctx context.Context, arg CountTimesByEventParams) ([]CountTimesByEventRow, error) {
	rows, err := q.db.Query(ctx, countTimesByEvent, arg.SwimmerID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CountTimesByEventRow{}
	for rows.Next() {
		var i CountTimesByEventRow
		if err := rows.Scan(&i.Event, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createTime = `-- name: CreateTime :one
INSERT INTO times (swimmer_id, meet_id, event, time_ms, event_date, notes)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, swimmer_id, meet_id, event, time_ms, event_date, notes, created_at, updated_at
`

type CreateTimeParams struct {
	SwimmerID uuid.UUID   `json:"swimmer_id"`
	MeetID    uuid.UUID   `json:"meet_id"`
	Event     string      `json:"event"`
	TimeMs    int32       `json:"time_ms"`
	EventDate pgtype.Date `json:"event_date"`
	Notes     pgtype.Text `json:"notes"`
}

func (q *Queries) CreateTime(ctx context.Context, arg CreateTimeParams) (Time, error) {
	row := q.db.QueryRow(ctx, createTime,
		arg.SwimmerID,
		arg.MeetID,
		arg.Event,
		arg.TimeMs,
		arg.EventDate,
		arg.Notes,
	)
	var i Time
	err := row.Scan(
		&i.ID,
		&i.SwimmerID,
		&i.MeetID,
		&i.Event,
		&i.TimeMs,
		&i.EventDate,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteTime = `-- name: DeleteTime :exec
DELETE FROM times
WHERE id = $1
`

func (q *Queries) DeleteTime(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteTime, id)
	return err
}

const deleteTimesByMeet = `-- name: DeleteTimesByMeet :exec
DELETE FROM times
WHERE meet_id = $1
`

func (q *Queries) DeleteTimesByMeet(ctx context.Context, meetID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteTimesByMeet, meetID)
	return err
}

const eventExistsForMeet = `-- name: EventExistsForMeet :one
SELECT EXISTS (
    SELECT 1 FROM times
    WHERE swimmer_id = $1
      AND meet_id = $2
      AND event = $3
) AS exists
`

type EventExistsForMeetParams struct {
	SwimmerID uuid.UUID `json:"swimmer_id"`
	MeetID    uuid.UUID `json:"meet_id"`
	Event     string    `json:"event"`
}

// Check if an event already exists for a specific meet and swimmer
func (q *Queries) EventExistsForMeet(ctx context.Context, arg EventExistsForMeetParams) (bool, error) {
	row := q.db.QueryRow(ctx, eventExistsForMeet, arg.SwimmerID, arg.MeetID, arg.Event)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getPersonalBestForEvent = `-- name: GetPersonalBestForEvent :one
SELECT 
    t.id,
    t.swimmer_id,
    t.meet_id,
    t.event,
    t.time_ms,
    t.event_date,
    t.notes,
    t.created_at,
    t.updated_at,
    m.name AS meet_name,
    m.start_date AS meet_date
FROM times t
JOIN meets m ON m.id = t.meet_id
WHERE t.swimmer_id = $1
  AND m.course_type = $2
  AND t.event = $3
ORDER BY t.time_ms ASC, COALESCE(t.event_date, m.start_date) DESC
LIMIT 1
`

type GetPersonalBestForEventParams struct {
	SwimmerID  uuid.UUID `json:"swimmer_id"`
	CourseType string    `json:"course_type"`
	Event      string    `json:"event"`
}

type GetPersonalBestForEventRow struct {
	ID        uuid.UUID   `json:"id"`
	SwimmerID uuid.UUID   `json:"swimmer_id"`
	MeetID    uuid.UUID   `json:"meet_id"`
	Event     string      `json:"event"`
	TimeMs    int32       `json:"time_ms"`
	EventDate pgtype.Date `json:"event_date"`
	Notes     pgtype.Text `json:"notes"`
	CreatedAt time.Time   `json:"created_at"`
	UpdatedAt time.Time   `json:"updated_at"`
	MeetName  string      `json:"meet_name"`
	MeetDate  pgtype.Date `json:"meet_date"`
}

// Returns the fastest time for a specific event
func (q *Queries) GetPersonalBestForEvent(ctx context.Context, arg GetPersonalBestForEventParams) (GetPersonalBestForEventRow, error) {
	row := q.db.QueryRow(ctx, getPersonalBestForEvent, arg.SwimmerID, arg.CourseType, arg.Event)
	var i GetPersonalBestForEventRow
	err := row.Scan(
		&i.ID,
		&i.SwimmerID,
		&i.MeetID,
		&i.Event,
		&i.TimeMs,
		&i.EventDate,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MeetName,
		&i.MeetDate,
	)
	return i, err
}

const getPersonalBests = `-- name: GetPersonalBests :many
SELECT DISTINCT ON (t.event)
    t.id,
    t.swimmer_id,
    t.meet_id,
    t.event,
    t.time_ms,
    t.event_date,
    t.notes,
    t.created_at,
    t.updated_at,
    m.name AS meet_name,
    m.start_date AS meet_date
FROM times t
JOIN meets m ON m.id = t.meet_id
WHERE t.swimmer_id = $1
  AND m.course_type = $2
ORDER BY t.event, t.time_ms ASC, COALESCE(t.event_date, m.start_date) DESC
`

type GetPersonalBestsParams struct {
	SwimmerID  uuid.UUID `json:"swimmer_id"`
	CourseType string    `json:"course_type"`
}

type GetPersonalBestsRow struct {
	ID        uuid.UUID   `json:"id"`
	SwimmerID uuid.UUID   `json:"swimmer_id"`
	MeetID    uuid.UUID   `json:"meet_id"`
	Event     string      `json:"event"`
	TimeMs    int32       `json:"time_ms"`
	EventDate pgtype.Date `json:"event_date"`
	Notes     pgtype.Text `json:"notes"`
	CreatedAt time.Time   `json:"created_at"`
	UpdatedAt time.Time   `json:"updated_at"`
	MeetName  string      `json:"meet_name"`
	MeetDate  pgtype.Date `json:"meet_date"`
}

// Returns the fastest time for each event for a swimmer in a specific course type
func (q *Queries) GetPersonalBests(ctx context.Context, arg GetPersonalBestsParams) ([]GetPersonalBestsRow, error) {
	rows, err := q.db.Query(ctx, getPersonalBests, arg.SwimmerID, arg.CourseType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPersonalBestsRow{}
	for rows.Next() {
		var i GetPersonalBestsRow
		if err := rows.Scan(
			&i.ID,
			&i.SwimmerID,
			&i.MeetID,
			&i.Event,
			&i.TimeMs,
			&i.EventDate,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.MeetName,
			&i.MeetDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProgressData = `-- name: GetProgressData :many
SELECT
    t.id,
    t.time_ms,
    COALESCE(t.event_date, m.start_date) AS date,
    m.name AS meet_name,
    t.event,
    -- Check if this time is the personal best (fastest time for this event/course)
    (t.time_ms = (
        SELECT MIN(t2.time_ms)
        FROM times t2
        JOIN meets m2 ON m2.id = t2.meet_id
        WHERE t2.swimmer_id = t.swimmer_id
          AND m2.course_type = m.course_type
          AND t2.event = t.event
    )) AS is_pb
FROM times t
JOIN meets m ON m.id = t.meet_id
WHERE t.swimmer_id = $1
  AND m.course_type = $2
  AND t.event = $3
  AND ($4::date IS NULL OR COALESCE(t.event_date, m.start_date) >= $4)
  AND ($5::date IS NULL OR COALESCE(t.event_date, m.start_date) <= $5)
ORDER BY COALESCE(t.event_date, m.start_date) ASC, t.time_ms ASC
`

type GetProgressDataParams struct {
	SwimmerID  uuid.UUID   `json:"swimmer_id"`
	CourseType string      `json:"course_type"`
	Event      string      `json:"event"`
	Column4    pgtype.Date `json:"column_4"`
	Column5    pgtype.Date `json:"column_5"`
}

type GetProgressDataRow struct {
	ID       uuid.UUID   `json:"id"`
	TimeMs   int32       `json:"time_ms"`
	Date     pgtype.Date `json:"date"`
	MeetName string      `json:"meet_name"`
	Event    string      `json:"event"`
	IsPb     bool        `json:"is_pb"`
}

// Returns time progression for a specific event over time
// Used for progress charts visualization
func (q *Queries) GetProgressData(ctx context.Context, arg GetProgressDataParams) ([]GetProgressDataRow, error) {
	rows, err := q.db.Query(ctx, getProgressData,
		arg.SwimmerID,
		arg.CourseType,
		arg.Event,
		arg.Column4,
		arg.Column5,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProgressDataRow{}
	for rows.Next() {
		var i GetProgressDataRow
		if err := rows.Scan(
			&i.ID,
			&i.TimeMs,
			&i.Date,
			&i.MeetName,
			&i.Event,
			&i.IsPb,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTime = `-- name: GetTime :one
SELECT 
    t.id, 
    t.swimmer_id, 
    t.meet_id, 
    t.event, 
    t.time_ms, 
    t.event_date,
    t.notes, 
    t.created_at, 
    t.updated_at
FROM times t
WHERE t.id = $1
`

func (q *Queries) GetTime(ctx context.Context, id uuid.UUID) (Time, error) {
	row := q.db.QueryRow(ctx, getTime, id)
	var i Time
	err := row.Scan(
		&i.ID,
		&i.SwimmerID,
		&i.MeetID,
		&i.Event,
		&i.TimeMs,
		&i.EventDate,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTimeWithMeet = `-- name: GetTimeWithMeet :one
SELECT 
    t.id, 
    t.swimmer_id, 
    t.meet_id, 
    t.event, 
    t.time_ms, 
    t.event_date,
    t.notes, 
    t.created_at, 
    t.updated_at,
    m.name AS meet_name,
    m.city AS meet_city,
    m.start_date AS meet_start_date,
    m.end_date AS meet_end_date,
    m.course_type AS meet_course_type
FROM times t
JOIN meets m ON m.id = t.meet_id
WHERE t.id = $1
`

type GetTimeWithMeetRow struct {
	ID             uuid.UUID   `json:"id"`
	SwimmerID      uuid.UUID   `json:"swimmer_id"`
	MeetID         uuid.UUID   `json:"meet_id"`
	Event          string      `json:"event"`
	TimeMs         int32       `json:"time_ms"`
	EventDate      pgtype.Date `json:"event_date"`
	Notes          pgtype.Text `json:"notes"`
	CreatedAt      time.Time   `json:"created_at"`
	UpdatedAt      time.Time   `json:"updated_at"`
	MeetName       string      `json:"meet_name"`
	MeetCity       string      `json:"meet_city"`
	MeetStartDate  pgtype.Date `json:"meet_start_date"`
	MeetEndDate    pgtype.Date `json:"meet_end_date"`
	MeetCourseType string      `json:"meet_course_type"`
}

func (q *Queries) GetTimeWithMeet(ctx context.Context, id uuid.UUID) (GetTimeWithMeetRow, error) {
	row := q.db.QueryRow(ctx, getTimeWithMeet, id)
	var i GetTimeWithMeetRow
	err := row.Scan(
		&i.ID,
		&i.SwimmerID,
		&i.MeetID,
		&i.Event,
		&i.TimeMs,
		&i.EventDate,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MeetName,
		&i.MeetCity,
		&i.MeetStartDate,
		&i.MeetEndDate,
		&i.MeetCourseType,
	)
	return i, err
}

const getTotalMeetCount = `-- name: GetTotalMeetCount :one
SELECT COUNT(DISTINCT meet_id)::int FROM times
WHERE swimmer_id = $1
`

func (q *Queries) GetTotalMeetCount(ctx context.Context, swimmerID uuid.UUID) (int32, error) {
	row := q.db.QueryRow(ctx, getTotalMeetCount, swimmerID)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const getTotalTimeCount = `-- name: GetTotalTimeCount :one
SELECT COUNT(*)::int FROM times
WHERE swimmer_id = $1
`

func (q *Queries) GetTotalTimeCount(ctx context.Context, swimmerID uuid.UUID) (int32, error) {
	row := q.db.QueryRow(ctx, getTotalTimeCount, swimmerID)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const isPersonalBest = `-- name: IsPersonalBest :one
SELECT NOT EXISTS (
    SELECT 1 FROM times t
    JOIN meets m ON m.id = t.meet_id
    WHERE t.swimmer_id = $1
      AND m.course_type = $2
      AND t.event = $3
      AND t.time_ms <= $4
      AND t.id != $5
) AS is_pb
`

type IsPersonalBestParams struct {
	SwimmerID  uuid.UUID `json:"swimmer_id"`
	CourseType string    `json:"course_type"`
	Event      string    `json:"event"`
	TimeMs     int32     `json:"time_ms"`
	ID         uuid.UUID `json:"id"`
}

// Check if a given time is faster than all existing times for this event/course
func (q *Queries) IsPersonalBest(ctx context.Context, arg IsPersonalBestParams) (bool, error) {
	row := q.db.QueryRow(ctx, isPersonalBest,
		arg.SwimmerID,
		arg.CourseType,
		arg.Event,
		arg.TimeMs,
		arg.ID,
	)
	var is_pb bool
	err := row.Scan(&is_pb)
	return is_pb, err
}

const listTimes = `-- name: ListTimes :many
SELECT 
    t.id, 
    t.swimmer_id, 
    t.meet_id, 
    t.event, 
    t.time_ms, 
    t.event_date,
    t.notes, 
    t.created_at, 
    t.updated_at,
    m.name AS meet_name,
    m.city AS meet_city,
    m.start_date AS meet_start_date,
    m.end_date AS meet_end_date,
    m.course_type AS meet_course_type
FROM times t
JOIN meets m ON m.id = t.meet_id
WHERE t.swimmer_id = $1
  AND ($2::varchar = '' OR m.course_type = $2)
  AND ($3::varchar = '' OR t.event = $3)
  AND ($4::uuid = '00000000-0000-0000-0000-000000000000' OR t.meet_id = $4)
ORDER BY COALESCE(t.event_date, m.start_date) DESC, t.event
LIMIT $5 OFFSET $6
`

type ListTimesParams struct {
	SwimmerID uuid.UUID `json:"swimmer_id"`
	Column2   string    `json:"column_2"`
	Column3   string    `json:"column_3"`
	Column4   uuid.UUID `json:"column_4"`
	Limit     int32     `json:"limit"`
	Offset    int32     `json:"offset"`
}

type ListTimesRow struct {
	ID             uuid.UUID   `json:"id"`
	SwimmerID      uuid.UUID   `json:"swimmer_id"`
	MeetID         uuid.UUID   `json:"meet_id"`
	Event          string      `json:"event"`
	TimeMs         int32       `json:"time_ms"`
	EventDate      pgtype.Date `json:"event_date"`
	Notes          pgtype.Text `json:"notes"`
	CreatedAt      time.Time   `json:"created_at"`
	UpdatedAt      time.Time   `json:"updated_at"`
	MeetName       string      `json:"meet_name"`
	MeetCity       string      `json:"meet_city"`
	MeetStartDate  pgtype.Date `json:"meet_start_date"`
	MeetEndDate    pgtype.Date `json:"meet_end_date"`
	MeetCourseType string      `json:"meet_course_type"`
}

func (q *Queries) ListTimes(ctx context.Context, arg ListTimesParams) ([]ListTimesRow, error) {
	rows, err := q.db.Query(ctx, listTimes,
		arg.SwimmerID,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTimesRow{}
	for rows.Next() {
		var i ListTimesRow
		if err := rows.Scan(
			&i.ID,
			&i.SwimmerID,
			&i.MeetID,
			&i.Event,
			&i.TimeMs,
			&i.EventDate,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.MeetName,
			&i.MeetCity,
			&i.MeetStartDate,
			&i.MeetEndDate,
			&i.MeetCourseType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTimesByMeet = `-- name: ListTimesByMeet :many
SELECT 
    t.id, 
    t.swimmer_id, 
    t.meet_id, 
    t.event, 
    t.time_ms, 
    t.event_date,
    t.notes, 
    t.created_at, 
    t.updated_at
FROM times t
WHERE t.meet_id = $1
ORDER BY COALESCE(t.event_date, (SELECT start_date FROM meets WHERE id = t.meet_id)), t.event, t.time_ms
`

func (q *Queries) ListTimesByMeet(ctx context.Context, meetID uuid.UUID) ([]Time, error) {
	rows, err := q.db.Query(ctx, listTimesByMeet, meetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Time{}
	for rows.Next() {
		var i Time
		if err := rows.Scan(
			&i.ID,
			&i.SwimmerID,
			&i.MeetID,
			&i.Event,
			&i.TimeMs,
			&i.EventDate,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTime = `-- name: UpdateTime :one
UPDATE times
SET meet_id = $2, event = $3, time_ms = $4, event_date = $5, notes = $6
WHERE id = $1
RETURNING id, swimmer_id, meet_id, event, time_ms, event_date, notes, created_at, updated_at
`

type UpdateTimeParams struct {
	ID        uuid.UUID   `json:"id"`
	MeetID    uuid.UUID   `json:"meet_id"`
	Event     string      `json:"event"`
	TimeMs    int32       `json:"time_ms"`
	EventDate pgtype.Date `json:"event_date"`
	Notes     pgtype.Text `json:"notes"`
}

func (q *Queries) UpdateTime(ctx context.Context, arg UpdateTimeParams) (Time, error) {
	row := q.db.QueryRow(ctx, updateTime,
		arg.ID,
		arg.MeetID,
		arg.Event,
		arg.TimeMs,
		arg.EventDate,
		arg.Notes,
	)
	var i Time
	err := row.Scan(
		&i.ID,
		&i.SwimmerID,
		&i.MeetID,
		&i.Event,
		&i.TimeMs,
		&i.EventDate,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
