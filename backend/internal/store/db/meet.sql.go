// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: meet.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countMeets = `-- name: CountMeets :one
SELECT COUNT(*) FROM meets
WHERE ($1::varchar = '' OR course_type = $1)
`

func (q *Queries) CountMeets(ctx context.Context, dollar_1 string) (int64, error) {
	row := q.db.QueryRow(ctx, countMeets, dollar_1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createMeet = `-- name: CreateMeet :one
INSERT INTO meets (name, city, country, start_date, end_date, course_type)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, name, city, country, start_date, end_date, course_type, created_at, updated_at
`

type CreateMeetParams struct {
	Name       string      `json:"name"`
	City       string      `json:"city"`
	Country    string      `json:"country"`
	StartDate  pgtype.Date `json:"start_date"`
	EndDate    pgtype.Date `json:"end_date"`
	CourseType string      `json:"course_type"`
}

func (q *Queries) CreateMeet(ctx context.Context, arg CreateMeetParams) (Meet, error) {
	row := q.db.QueryRow(ctx, createMeet,
		arg.Name,
		arg.City,
		arg.Country,
		arg.StartDate,
		arg.EndDate,
		arg.CourseType,
	)
	var i Meet
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.City,
		&i.Country,
		&i.StartDate,
		&i.EndDate,
		&i.CourseType,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteMeet = `-- name: DeleteMeet :exec
DELETE FROM meets
WHERE id = $1
`

func (q *Queries) DeleteMeet(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteMeet, id)
	return err
}

const getMeet = `-- name: GetMeet :one
SELECT id, name, city, country, start_date, end_date, course_type, created_at, updated_at
FROM meets
WHERE id = $1
`

func (q *Queries) GetMeet(ctx context.Context, id uuid.UUID) (Meet, error) {
	row := q.db.QueryRow(ctx, getMeet, id)
	var i Meet
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.City,
		&i.Country,
		&i.StartDate,
		&i.EndDate,
		&i.CourseType,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMeetWithTimeCount = `-- name: GetMeetWithTimeCount :one
SELECT 
    m.id, 
    m.name, 
    m.city, 
    m.country, 
    m.start_date,
    m.end_date,
    m.course_type, 
    m.created_at, 
    m.updated_at,
    COUNT(t.id)::int AS time_count
FROM meets m
LEFT JOIN times t ON t.meet_id = m.id
WHERE m.id = $1
GROUP BY m.id
`

type GetMeetWithTimeCountRow struct {
	ID         uuid.UUID   `json:"id"`
	Name       string      `json:"name"`
	City       string      `json:"city"`
	Country    string      `json:"country"`
	StartDate  pgtype.Date `json:"start_date"`
	EndDate    pgtype.Date `json:"end_date"`
	CourseType string      `json:"course_type"`
	CreatedAt  time.Time   `json:"created_at"`
	UpdatedAt  time.Time   `json:"updated_at"`
	TimeCount  int32       `json:"time_count"`
}

func (q *Queries) GetMeetWithTimeCount(ctx context.Context, id uuid.UUID) (GetMeetWithTimeCountRow, error) {
	row := q.db.QueryRow(ctx, getMeetWithTimeCount, id)
	var i GetMeetWithTimeCountRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.City,
		&i.Country,
		&i.StartDate,
		&i.EndDate,
		&i.CourseType,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TimeCount,
	)
	return i, err
}

const getRecentMeets = `-- name: GetRecentMeets :many
SELECT 
    m.id, 
    m.name, 
    m.city, 
    m.country, 
    m.start_date,
    m.end_date,
    m.course_type, 
    m.created_at, 
    m.updated_at,
    COUNT(t.id)::int AS time_count
FROM meets m
LEFT JOIN times t ON t.meet_id = m.id
WHERE ($1::varchar = '' OR m.course_type = $1)
GROUP BY m.id
ORDER BY m.start_date DESC
LIMIT $2
`

type GetRecentMeetsParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
}

type GetRecentMeetsRow struct {
	ID         uuid.UUID   `json:"id"`
	Name       string      `json:"name"`
	City       string      `json:"city"`
	Country    string      `json:"country"`
	StartDate  pgtype.Date `json:"start_date"`
	EndDate    pgtype.Date `json:"end_date"`
	CourseType string      `json:"course_type"`
	CreatedAt  time.Time   `json:"created_at"`
	UpdatedAt  time.Time   `json:"updated_at"`
	TimeCount  int32       `json:"time_count"`
}

func (q *Queries) GetRecentMeets(ctx context.Context, arg GetRecentMeetsParams) ([]GetRecentMeetsRow, error) {
	rows, err := q.db.Query(ctx, getRecentMeets, arg.Column1, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRecentMeetsRow{}
	for rows.Next() {
		var i GetRecentMeetsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.City,
			&i.Country,
			&i.StartDate,
			&i.EndDate,
			&i.CourseType,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TimeCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMeets = `-- name: ListMeets :many
SELECT 
    m.id, 
    m.name, 
    m.city, 
    m.country, 
    m.start_date,
    m.end_date,
    m.course_type, 
    m.created_at, 
    m.updated_at,
    COUNT(t.id)::int AS time_count
FROM meets m
LEFT JOIN times t ON t.meet_id = m.id
WHERE ($1::varchar = '' OR m.course_type = $1)
GROUP BY m.id
ORDER BY m.start_date DESC
LIMIT $2 OFFSET $3
`

type ListMeetsParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type ListMeetsRow struct {
	ID         uuid.UUID   `json:"id"`
	Name       string      `json:"name"`
	City       string      `json:"city"`
	Country    string      `json:"country"`
	StartDate  pgtype.Date `json:"start_date"`
	EndDate    pgtype.Date `json:"end_date"`
	CourseType string      `json:"course_type"`
	CreatedAt  time.Time   `json:"created_at"`
	UpdatedAt  time.Time   `json:"updated_at"`
	TimeCount  int32       `json:"time_count"`
}

func (q *Queries) ListMeets(ctx context.Context, arg ListMeetsParams) ([]ListMeetsRow, error) {
	rows, err := q.db.Query(ctx, listMeets, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListMeetsRow{}
	for rows.Next() {
		var i ListMeetsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.City,
			&i.Country,
			&i.StartDate,
			&i.EndDate,
			&i.CourseType,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TimeCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMeet = `-- name: UpdateMeet :one
UPDATE meets
SET name = $2, city = $3, country = $4, start_date = $5, end_date = $6, course_type = $7
WHERE id = $1
RETURNING id, name, city, country, start_date, end_date, course_type, created_at, updated_at
`

type UpdateMeetParams struct {
	ID         uuid.UUID   `json:"id"`
	Name       string      `json:"name"`
	City       string      `json:"city"`
	Country    string      `json:"country"`
	StartDate  pgtype.Date `json:"start_date"`
	EndDate    pgtype.Date `json:"end_date"`
	CourseType string      `json:"course_type"`
}

func (q *Queries) UpdateMeet(ctx context.Context, arg UpdateMeetParams) (Meet, error) {
	row := q.db.QueryRow(ctx, updateMeet,
		arg.ID,
		arg.Name,
		arg.City,
		arg.Country,
		arg.StartDate,
		arg.EndDate,
		arg.CourseType,
	)
	var i Meet
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.City,
		&i.Country,
		&i.StartDate,
		&i.EndDate,
		&i.CourseType,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
